# Django Custom User Model

## Benefits of Using a Django Custom User Model

- **Flexibility:** Allows customizing user fields according to project requirements.
- **Scalability:** Better handles future changes in user data without affecting existing data.
- **Enhanced Security:** Provides options to use email or other unique identifiers as the login username.
- **Avoiding Constraints:** Avoids constraints imposed by the default User Model, enabling a more tailored approach.

## Difference from the Default Django User Model

The default Django User Model has fixed fields like username, email, and password. In contrast, a Custom User Model allows developers to define their own fields based on specific project needs.

## Creating and Implementing a Custom User Model in Django

To create and implement a Custom User Model in Django, follow these steps:

1. Create a new Django app (`users`) for the custom model.
2. Define the Custom User Model class in `models.py` of the `users` app, extending `AbstractBaseUser` and `PermissionsMixin`.
3. Add the necessary user fields (e.g., `email`, `username`, etc.) in the model.
4. Implement a Custom User Manager (optional) to handle user creation and authentication logic.
5. Update the `AUTH_USER_MODEL` setting in `settings.py` to point to the newly created Custom User Model.
6. Run migrations to apply the changes to the database.

Example of Custom User Model class in `models.py`:

```python
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.db import models

class CustomUserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        # Custom user creation logic
        pass

class CustomUser(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True)
    username = models.CharField(max_length=150, unique=True)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    objects = CustomUserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']

    def __str__(self):
        return self.email

# DjangoX: Complementing or Extending Django Functionality

DjangoX is a Django starter project with pre-configured and opinionated setup, including various useful packages and configurations. It extends Django's functionality by incorporating additional features and best practices, making it easier to start new projects.

## Example Use Case for DjangoX

An example use case for DjangoX is creating an e-commerce website with Django. By using DjangoX, you get a pre-configured project with common e-commerce features like authentication, product management, shopping cart, payment integration, and user analytics. This saves development time and ensures a robust foundation to build upon.

# Django Template Checklist

[Django Template Link](https://github.com/wsvincent/djangox "Let's DjanGO")

Create a Django Project:
Use the django-admin command to create a new Django project:

Copy code
django-admin startproject project_name
This will create a project directory with the given name.

Create a Django App:
Inside the project directory, create a new app using the manage.py command:

Copy code
python manage.py startapp app_name
Apps are modular components in a Django project that handle specific functionality.

Define Models:
In the app's models.py file, define the database models using Django's model classes. Models represent the structure of the database tables.

Register the App:
Include the newly created app in the project's settings.py file under the INSTALLED_APPS list.

Create and Apply Migrations:
Generate migrations based on the defined models and apply them to create database tables:

Copy code
python manage.py makemigrations
python manage.py migrate
Create Views:
In the app's views.py file, create view functions that handle HTTP requests and return HTTP responses. Views interact with models to retrieve or update data.

Create URLs Mapping:
In the app's urls.py file, define URL patterns and map them to corresponding views using Django's URL patterns.

Include App URLs in Project URLs:
In the project's urls.py file, include the app's URL patterns using include() function to ensure they are reachable.

Create Templates (Optional):
If needed, create HTML templates in the app's templates directory to render dynamic content from views.

Static Files (Optional):
For static files like CSS, JavaScript, and images, create a static directory in the app and store them accordingly.

Configure Settings:
Adjust the project's settings in settings.py file, such as database configuration, static files, etc.

Run the Development Server:
Start the development server to test the application locally:

Copy code
python manage.py runserver
Create Superuser (Optional):
To access the Django admin interface, create a superuser account:

Copy code
python manage.py createsuperuser
Admin Interface (Optional):
Register models in the app's admin.py file to manage them through Django's admin interface.

Test the Application:
Access the application in a web browser or via API client (like Postman) to ensure it's functioning as expected.

Remember, this is just a basic checklist to get you started. As your project grows, you may need to add more components and implement more advanced features, but this checklist should give you a solid foundation for a Django project.