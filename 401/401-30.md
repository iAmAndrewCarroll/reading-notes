# Understanding Hash Tables with the Library Index Analogy

## Why use a hash table (The Library Index System):

The library index system (hash table) is used to quickly find the book (value) associated with a given title (key). It ensures that accessing information in the library becomes faster and more efficient, as the librarian can directly go to the specific shelf (index) where the book is located.

## What is a hash table (The Library Index):

A hash table is a data structure that maps keys (book titles) to values (book locations) using a hash function. The hash function takes a book title as input and generates a unique index (shelf number) where the book will be stored in an array.

## How does a hash table work (Library Indexing Process):

1. When a new book (key) arrives in the library, the librarian applies the hash function (indexing rule) to determine its shelf number (index).
2. The librarian then places the book on the designated shelf according to the calculated index.
3. Now, whenever someone wants to find a book, they provide its title (key) to the librarian.
4. The librarian applies the same hash function to the title to find the corresponding shelf (index) quickly.
5. Finally, the librarian retrieves the book from the identified shelf (value) and provides it to the reader.

## Advantages of the Library Index System (Hash Table):

1. Fast lookup: With the library index system, finding a book becomes a breeze. The librarian can directly navigate to the shelf where the book is stored, saving time and effort.
2. Space efficient: The library index system ensures that books are distributed evenly across the shelves, utilizing the available space effectively.
3. Flexible: The library index system is versatile and can handle any book title (key) and corresponding location (value) regardless of their content.

## Disadvantages of the Library Index System (Hash Table):

1. Collisions: Sometimes, two different books may end up with the same shelf number due to the nature of the hash function. This creates collisions and might slow down the search process.
2. Expensive to initialize: Creating the library index system can be time-consuming and computationally expensive, as the librarian needs to calculate the shelf number for each book.

In conclusion, just like a well-organized library index system, hash tables provide an efficient way to store and retrieve data quickly. By understanding this analogy, you can grasp the concepts behind hash tables and appreciate their benefits and limitations in various applications.

# Resources:

### Read:
- [Hash Tables (CodeFellows)](https://codefellows.github.io/common_curriculum/data_structures_and_algorithms/Code_401/class-30/resources/Hashtables.html)

### Watch:
- [Hash Tables Explained (YouTube)](https://www.youtube.com/watch?v=MfhjkfocRR0)

### Read:
- [Basics of Hash Tables (HackerEarth)](https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/)

### Skim:
- [Hash Table (Wikipedia)](https://en.wikipedia.org/wiki/Hash_table)

# Lecture Notes

class Hashtable():
  """
  This is the doc string that explains what is going on with the code. It will show up when you hover over Hashtable() in other parts of the code.
  Parameter: Key, Value
  Returns: Nothing

  autoDocstring is a doc string extension for VS Code
  """


  def __int__(self, size=10):
    <!-- the _size typically signasl that size is fixed.  -->
    self._size = size
    self._buckets = size * [None]

  def hash(self, key):
    """
    hash
    Arguments: key
    Returns: Index in the collection for that key
    :return:
    """
    <!-- this will return an index within the range of our hashtable -->
    <!-- We are going to give it a key of
    super
    ^ 
    jump = 106 + 117 + 109 + 112 = 446 > modulo to 44.6 > gets placed in index 6-->
    <!-- ord() returns the ascii value of a character, in the first instance of this function it will return s = 115 
    total = 0 + 115 + 117 + 112 + 101 + 114; total = 560 
    primed = 560 * 19 = 10640 = primed
    10640 % modulo divides by 10 and give the remainder
    ['super: 100', None, None, None, None, None, None, None, None, None] -->
    total = 0
    for ch in key: 
      total += orc(ch)
    primed = total * 19
    index = primed % self.size
    return index
    <!-- index = 0
    return index -->

if __name__ == '__main__':
  hash1 = Hashtable()
  print(hash1._buckets)