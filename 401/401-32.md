### Django Rest Framework (DRF) Permissions

DRF Permissions are key components in Django Rest Framework that provide a way to control access to APIs. They help secure an API by defining who can perform certain actions based on user roles and permissions.

There are several types of DRF Permissions:

1. **IsAuthenticated**: Ensures that only authenticated users can access the API.
2. **IsAdminUser**: Allows access only to admin users.
3. **IsAuthenticatedOrReadOnly**: Allows read access to any user but requires authentication for write operations.
4. **AllowAny**: Permits access to anyone, whether authenticated or not.

By utilizing these permissions, you can control which users can view, create, update, or delete resources within your API, making it more secure and tailored to your specific use case.

### SQL SELECT Statement

In SQL, the `SELECT` statement is used to retrieve data from a database table. It allows you to specify which columns you want to retrieve and apply filters to narrow down the results.

To retrieve all columns from a table called 'employees', the query would be:

```SELECT * FROM employees; * wildcard for all columns in employees table. returns all rows/columns of data stored in the table```

### Role of DRF Generic Views

DRF Generic Views are pre-built views provided by Django Rest Framework to simplify the creation of RESTful APIs. They abstract common patterns and logic, reducing the amount of code you need to write for typical operations.

These views serve as reusable components that handle common actions such as retrieving a list of objects, creating new objects, updating existing objects, and retrieving a single object by its ID. By using DRF Generic Views, you can implement standard CRUD (Create, Retrieve, Update, Delete) operations with minimal effort.

Instead of writing custom views and handling repetitive tasks for different API endpoints, you can leverage DRF Generic Views to streamline the development process, improve code maintainability, and ensure consistency in your API design.

DRF Generic Views are highly flexible and can be easily extended and customized to suit your specific requirements. They are an essential part of building RESTful APIs efficiently and effectively using Django Rest Framework.

# In Class Notes

added new path in project urls.py
from rest_framework import permissions
touch spotify/permissions.py
  from rest_framework import permissions
  class IsOwnerOrReadOnly(permissions.BasePermission):
    def has_object_permission(self, request, view, obj):

      if request.method in permission.SAFE_METHODS:
        return True

      if obj.owner is None:
        return True

      return obj.owner = request.user

go to spotify/views
  from .permissions import IsOwnerOrReadOnly

  Modify the following
    class SpotifyList(generics.ListCreateAPIView):
      <!-- added permission_classes line -->
      permission_classes = (IsOwnerOrReadOnly, )
      queryset = Spotify.objects.all()
      serializer_class = SpotifySerializer

    class SpotifyDetail(generics.RetrieveUpdateDestroyAPIView):
      <!-- added permission_classes line -->
      permission_classes = (IsOwnerOrReadOnly, )
      queryset = Spotify.objects.all()
      serializer_class = SpotifySerializer

10:42hrs - Moving Away from SQL Database

10:55ish hrs - docker-compose.yml information

11:10hrs
  added to the docker-compose.yml
    depends_on:
      - db
  db:
    image: postgres
    environment:
      - POSTGRES...

  More changes will be required in the settings.py
    <!-- DATABASES = {
      'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
      }
    } -->
    DATABASES = {
      "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "postgres",
        "USER": "postgres",

      }
    }

    pip install psycopg2-binary
    pip freeze > requirements.txt
    dcu --build
      - an error that said 19 migrations needed
      - python manage.py migrate didn't work
      - python manage.py makemigrations returns "no changes detected"
      - the dcu build is running inside the docker container
      - the migrate commands are running in our venv
      - so the migrate commands are not being run on the docker container
        - so how do we solve this?
        - we need to run python manage.py migrate inside the docker container
        - docker compose run web python manage.py migrate
        - then run dcu --build again (docker compose up)
        - to properly shutdown docker; docker compose down
          - you will lose the data inside your postgres database

Create a SuperUser inside the docker container
- docker compose run web python manage.py createsuperuser
- unapplied migrations again
  - docker compose up -d (dcu -d) runs it in a detached mode, bypasses the unapplied migrations
    - run migrate
    - now create superuser


Docker Compose
- docker compose up
- docker compose down
- docker compose start
- docker compose stop
- docker compose --help