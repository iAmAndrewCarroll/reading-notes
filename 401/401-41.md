## Dunder Methods

Dunder methods, or magic methods, are special functions in Python that allow customization of built-in behaviors in classes. They have a specific naming pattern with double underscores before and after their names. These methods provide hooks into fundamental operations, such as `__repr__`, which returns a string representation of an object.

Example:

    class Person:
        def __init__(self, name, age):
            self.name = name
            self.age = age

        def __repr__(self):
            return f"Person(name={self.name}, age={self.age})"

The `__repr__` method in this example provides a formatted string representation of a `Person` object, aiding in debugging and introspection.

## Iterators

Iterators enable sequential processing of elements in collections. To create a custom iterator, use the `iter()` and `next()` methods. `iter()` transforms an iterable into an iterator, while `next()` retrieves the next item from the sequence.

Example:

    class Counter:
        def __init__(self, start_value):
            self.value = start_value

        def __iter__(self):
            return self

        def __next__(self):
            if self.value is None:
                raise StopIteration
            else:
                value = self.value
                self.value += 1
                return value

The `Counter` iterator progresses through a sequence, enhancing the ability to traverse data structures.

## Generators

Generators efficiently produce sequences of values. Unlike regular functions, generators maintain state between invocations, improving memory efficiency. Create a generator using the `yield` keyword.

Example:

    def fibonacci(n):
        a, b = 0, 1
        for i in range(n):
            yield a
            a, b = b, a + b

The `fibonacci` generator method generates Fibonacci numbers on-the-fly, conserving memory by generating only what is needed.

## Decorators

Decorators enhance function behavior, promoting modularity and maintainability. Use the `@` symbol to mark a function as a decorator. Decorator functions wrap target functions, enabling pre- and post-processing.

Example:

    def my_decorator(func):
        def wrapper(*args, **kwargs):
            print("Before function invocation")
            result = func(*args, **kwargs)
            print("After function invocation")
            return result
        return wrapper

Apply decorators to functions, such as the `factorial` function below, to extend their functionality seamlessly.

@my_decorator
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

Decorators promote structured and modular design while enhancing function capabilities.

### Resources

Assigned reading, video, ChatGPT, Bard, Google, Classmates